{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"BukkitUtils","tagline":"Set of bukkit utilities","body":"Download: \r\n---------------------------\r\nYou can found the latest release [here](http://maven.aumgn.fr/fr/aumgn/bukkitutils/1.0.0-RC3/bukkitutils-1.0.0-RC3.jar).\r\n\r\nFor older et development versions, see [my maven repository](http://maven.aumgn.fr/fr/aumgn/bukkitutils).\r\n\r\nDevelopers :\r\n---------------------------\r\n### Installation :\r\n\r\nBukkitUtils is an external library that must be provided at runtime.\r\nThe easiest way to do that is to add a class path entry to your plugin's MANIFEST.\r\nWith Maven you just have to configure the the maven jar plugin as follows: \r\n\r\n``` xml\r\n    <plugin>\r\n        <groupId>org.apache.maven.plugins</groupId>\r\n      <artifactId>maven-jar-plugin</artifactId>\r\n    \t<version>2.3.2</version>\r\n    \t<configuration>\r\n    \t\t<archive>\r\n    \t\t\t<manifestEntries>\r\n    \t\t\t\t<Class-Path>../lib/BukkitUtils.jar</Class-Path>\r\n    \t\t    </manifestEntries>\r\n    \t\t</archive>\r\n    \t</configuration>\r\n    </plugin>\r\n```\r\n\r\nWhich means the user will have to provide the library at the corresponding path. You should prefer this path is this is the one which is used by other plugins.\r\n\r\n### Documentation\r\nThe javadoc is available [here](http://bukkitutils.aumgn.fr/apidocs/).\r\n\r\n### Usage\r\n\r\nBukkitUtils include different utilities :\r\n   - localization : Localization utilities\r\n   - commands : A set of classes and annotations to write commands more easily (heavily inspired from WorldEdit commands system).\r\n   - gconf: A tiny gson wrapper with convenient type adaptaters.\r\n   - playerId : A class (PlayerId) and its associated collections to manage players based on their names.\r\n   - and a lot of others utilities class and interface like immutable vectors, directions, timer class, etc ...\r\n\r\n#### Commands\r\n\r\nHere are some examples of how you would write commands with BukkitUtils : \r\n``` java\r\n    public class MyCommands extends Commands {\r\n    \r\n        // ** Simplest command\r\n        @Command(name = \"test\")\r\n        public void test(CommandSender sender) {\r\n            sender.sendMessage(\"Foo !\");\r\n        }\r\n    \r\n        // ** Player only command\r\n        @Command(name = \"test2\")\r\n        pubic void test2(Player sender) {\r\n            sender.sendMessage(\"Position: \" + new Vector(sender));\r\n        }\r\n    \r\n        // ** Command with two arguments\r\n        @Command(name = \"test3\", min = 2, max = 2)\r\n        public void test3(CommandSender sender, CommandArg args) {\r\n            sender.sendMessage(\"Arguments: \" + args.get(0) \" - \" + args.get(1));\r\n        }\r\n    \r\n        // ** Commands with complex arguments\r\n        // Try to parse the first argument as a partial player name.\r\n        // This will send a message and abort the command if no player \r\n        // or if more than one player is/are found.\r\n        // If no argument is given (which is accepted since \r\n        // min is set to 0), the library will return back the\r\n        // sender if it's a player or throw an exception\r\n        // (which will send a nice error message to the user)\r\n        // if it's not.\r\n        @Command(name = \"test4\", min = 0, max = 1)\r\n        public void test4(CommandSender sender, CommandArgs args) {\r\n            Player player = args.getPlayer(0).value(sender);\r\n            // Note that you can also use match() instead of value()\r\n            // which would returns a list of all matching players.\r\n            sender.sendMessage(\"Utilisation de la commande sur :\"\r\n                + player.getDisplayName());\r\n        }\r\n\r\n        // ** List arguments\r\n        // Using getPlayers instead of getPlayer will returns a list.\r\n        // For example : \"au,notch\" will returns a list of \r\n        // all players whose name matches au or notch\r\n        @Command(name = \"test5\", min = 0, max = 1)\r\n        public void test5(CommandSender sender, CommandArgs args) {\r\n            List<Player> players = args.getPlayers(0).match(sender);\r\n            sender.sendMessage(\"Utilisation de la commande sur :\");\r\n            for (Player player : players) {\r\n                sender.sendMessage(\" - \" + player.getDisplayName());\r\n            }\r\n        }\r\n\r\n        // ** Commands with flags\r\n        // Available flags must be declared in the annotation.\r\n        // If an invalid flag is used the sender will be notified.\r\n        @Command(name = \"test6\", flags = \"at\")\r\n        public void test6(CommandSender sender, CommandArgs args) {\r\n            if (args.hasFlag('a')) {\r\n                // Do something\r\n            } else if (args.hasFlag('t')) {\r\n                // Do something else\r\n            }\r\n        }\r\n\r\n        // ** Commands with argument flags\r\n        // The syntax is : \"/test6 -p=au -w=world\"\r\n        @Command(name = \"test6\", argsFlags = \"pw\")\r\n        public void test6(CommandSender sender, CommandArgs args) {\r\n            if (args.hasFlag('p')) {\r\n                Player player = args.get('p', Player.class).value();\r\n                // Do something with player.\r\n            } else if (args.hasFlag('w')) {\r\n                World world = args.get('w', World.class).value();\r\n                // Do something with world.\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\nIn to order to register your commands you just have to use the class CommandsRegistration : \r\n\r\n    CommandsRegistration registration = new CommandsRegistration(plugin, config.getLocale());\r\n    registration.register(new MyCommands());\r\n\r\nThis command system is quite powerful and extensible.\r\nYou can add your own arguments parsers using the classes CommandArg and CommandArgsFactory.\r\nSee example in the source code or in [my other plugins](https://github.com/aumgn/).\r\n\r\nThe main advantages of this system over others is that all commands (even nested commands) are first citizens Bukkit commands.\r\nWhich means they are declared in the plugin.yml with their own permission, that also means that users can declare their own aliases in the bukkit.yml file !\r\n\r\n#### Configuration Example\r\n\r\nHere's how you could write using the gson wrapper : \r\n``` java\r\n    public class MyConfig {\r\n    \r\n        private int entry1 = 1;\r\n        private String entry2 = \"string\";\r\n        private String entry3 = \"BLUE\";\r\n\r\n        public int getEntry1() {\r\n            return entry1;\r\n        }\r\n\r\n        public String getEntry2() {\r\n            return entry2;\r\n        }\r\n\r\n        public ChatColor getEntry3() {\r\n            try {\r\n                return ChatColor.valueOf(entry3);\r\n            } catch (IllegalArgumentException exc) {\r\n                Logger.getLogger(MyPlugin.class.getName()).severe(\"Invalid color for entry2.\");\r\n                return ChatColor.BLUE;\r\n            }\r\n        }\r\n    }\r\n\r\n    public class MyPlugin extends JavaPlugin {\r\n        \r\n        private MyConfig config;\r\n\r\n        @Override\r\n        public void onEnable() {\r\n            Gson gson = new GsonBuilder()\r\n                .setPrettyPrinting()\r\n                .create();\r\n            GConfLoader loader = new GConfLoader(gson, this);\r\n\r\n            try {\r\n                config = loader.load(\"config.json\", MyConfig.class);\r\n            } catch (GConfLoadException exc) {\r\n                getLogger().log(Level.SEVERE, \"Unable to load config.json\", exc);\r\n                config = new MyConfig();\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n"}